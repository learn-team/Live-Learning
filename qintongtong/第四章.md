ES 变量可能包含基本类型和引用类型。

基本类型值是指简单的数据段，如 Undefined、Null、Booblean、Number、String 就是按值访问的，因为它们可以操作保存在变量中的实际值。

引用类型是指那些可能由多个值构成的对象。JS 中不允许直接操作内存中的空间，所以在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。


###动态属性

对于引用类型我们可以为其添加属性和方法，也可以改变和删除其属性和方法。

对于基本类型就不可以添加属性和方法，尽管这样去做了不会导致任何错误，但实际被动态添加的属性和方法并不能使用。

###复制变量值

基本类型复制值以后是一个被复制值的副本，它是完全独立的。 复制值和被复制值在使用时相互没有任何影响。

引用类型复制值以后同样也是一个被复制值的副本，但与基本类型不同的是，副本是一个指针，而这个指针指向存储在堆中的一个对象。所以复制操作结束以后，两个对象将引用同一个对象，为此，改变其中一个变量，就会影响到另一个变量。

###传递参数

ES 中函数的参数( 基本类型、引用类型 )都是按值传递的。

###检测类型

基本类型使用 typeof，引用类型使用 instanceof 检测它是什么类型的对象。

所有引用类型都是 Object 的实例，因此在检测一个引用类型值和 Object 构造函数时， instanceof 始终返回 true。 而使用 instanceof 检测基本类型始终返回 false，因为基本类型不是对象。

###执行环境及作用域

 对于函数和变量在不同的环境中都有与之关联的变量对象，当前环境中的函数和变量都保存在这个对象中。虽然我们编写代码无法访问这个对象，但解析器在处理数据的时候会在后台使用它。

全局执行环境，是指最外层的执行环境。 在 Web 浏览器中全局执行环境被认为是 window 对象。

某个执行环境代码执行完毕后，该环境将被销毁。对于 window 对象而言，在浏览器或者网页被关闭时 window 环境才会被销毁。

每个函数都有一个执行环境，当执行流进入到一个函数时，函数的环境就会被推入到一个环境栈中。而在函数执行完成之后，栈会将其弹出，把控制权返回之前的执行环境。 ES 程序中的执行流正是由这个方便的机制控制着。

当代码在一个环境中执行时，会创建一个变量对象的作用域链。它的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行环境的变量对象。比如当前是函数环境，则将其活动对象作为变量对象。函数中第一个变量对象是 arguments，下一个对象变量是来自包含（外部）环境，而再下一个变量对象则是来自下一个包含环境。这样一直延续到全局执行环境。

标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索的过程始终从作用域链的前端开始，然后逐级地向后回溯。直到找到标识符，如果找不到通常会导致错误发生。

###延长作用域链

？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？没懂 4.2.1

###没有块级作用域

在其他类 C 的语言中，由花括号封闭的代码块都有自己的作用域，而对于 ES 来说这只是他们的执行环境。比如在 if 后的 {} 中声明的变量将会被添加到当前的执行环境。尤其是在 for 中需要注意，通常定义的 i 变量，在 for 结束后仍然可以访问。

###变量声明

使用 var 声明的变量会自动被添加到最接近的执行环境中。在函数内部最接近的环境是函数的局部环境，在 with 语句中，最接近的环境是函数环境。如果初始化没有 var 声明，该变量会自动添加到全局环境。

###查询标识符

当读取或者写入某个变量时，必须通过搜索来确定该标识符实际代表了什么。搜索过程从作用域链前端开始，向上逐级查询。如果找到了就停止搜索，否则一直追溯到全局执行环境。如果全局环境也没找到，则意味着该变量尚未声明。

###垃圾收集

函数中局部变量只在函数执行的过程中存在，而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储他们的值。当函数执行完毕，局部变量就没有存在的必要了。因此可以释放它们的内存供将来使用。

垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记。以备将来收回占用的内存。

标记无用变量的策略因实现而异，具体到浏览器中，通常有 标记清除 和 引用计数连个策略。

###标记清除

当变量进入环境（如：在函数中声明一个变量）时，就将这个变量标记为 “进入环境”。而当变量离开环境时，则加你