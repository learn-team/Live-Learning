面向对象( Object-Oriented, OO )的语言有一个标志，那就是它们都有类的概念，通过类可以创建任意多个具有相同属性和方法的对象。而 ECMAScript 中没有类的概念，所有它的对象也是基于类的语言中的对象有所不同。

ECMA-262 把对象定义为： `无序属性的集合，其属性可以包含基本值、对象或者函数`，严格来讲就相当于说对象是一组没有特定顺序的值。对象的每个属性或者方法都有一个名字，而每个名字都映射到一个值，正因为这样，我们可以把 ECMAScript 的对象想象成散列表，无非就是一组名值对，其中值可以使数据或函数。

每个对象都是基于 ECMAScript 任何一个引用类型创建的，也可以是开发者自己定义的类型。

####理解对象

创建一个自定义对象最简单的方法是先创建一个 Object 实例，然后再为它添加属性和方法：

    var person = new Object();
    person.age = 23;
    person.fn = function(){};

早期的 JS 开发者经常使用这种模式，而几年后对象字面量成为创建对象的首选模式，如将上面的实例改造：
  
    var person = {
        age: 29,
        fn: function(){}
    }
    
这个实例与之前 new Object 实例对象是一样的，都有相同的属性和方法。这些属性在创建时都带有一些特征值( characteristic )， JavaScript 通过这些特征值来定义它们的行为。
    
####属性类型

ECMA-262 第 5 版在定义只有内部采用的特性( attribute )时，描述了属性( property ) 的各种特征。ECMA-262 定义这些特性是为了实现 JavaScript 引擎使用的，因此在 JavaScript 中不能直接访问它们。为了表示特性是内部直，该规范把它们放在了两对儿方括号中，例如[[Enumerable]]。

ECMAScript 中有两种属性：数据属性和访问器属性。

#####数据属性

数据属性包含一个数据值的位置，在这个位置可以读取和写入值，数据属性有 4 个描述其行为的特性：

1. [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面实例中那样直接在对象上定义的属性，他们的这个特性默认值为 true。
2. [[Enumerable]]：表示能否通过 for-in  循环返回属性。像前面实例中那样直接在对象上定义的属性，这个特性默认值为 true。
3. [[Writable]]：表示能否修改属性的值。像前面实例中那样直接在对象上定义的属性，这个特性默认值为 true。
4. [[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置，这个特性的默认值为 undefind。比如前面实例中的 age [[Value]] 特性被设置为指定的值 29。 

要修改属性的特性，必须使用 ECMAScript 5 的 Object.defineProperty() 方法，该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中描述符( descriptor )对象的属性必须是：configurable、enumerable、writable和value。设置其中的一个或多个值，可以修改对应的特性值：

    var person = {};
    Object.defineProperty( person, 'name', {
        writable: fasle,
        value: 'mingxing'
    };
    console.log( person.name ); // mingxing
    person.name = 'tongtong';
    console.log( person.name ); // mingxing

这个实例创建了一个名为 name 的属性，它的值 'mingxing' 是只读的。这个属性的值时不可以修改的，如果尝试为它指定新值，在非严格模式下，复制操作将被忽略；而在严格模式下赋值操作将会抛出错误。

多数情况下，可能没有必要使用 Object.defineProperty() 方法提供的这些高级功能，不过理解这些概念对理解 JavaScript 对象却非常有用。

####访问器属性

访问器属性不包含数据值；而是包含一对儿 getter 和 setter 函数( *不过这两个函数都不是必须的* )，在读取访问器属性时，会调用 setter 函数，这个函数负责返回有效的值。在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性：

1. [[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。
2. [[Get]]：在读取属性时调用的函数。默认值为 undefined。
3. [[Set]]：在写入属性时调用的函数。默认值为 undefined。

访问器属性不能直接定义，必须使用 Object.defineProperty() 来定义，如下：

    var book = {_year: 2004, edition: 1 };
    Object.defineProperty(book, 'year', {
        get: function(){
            return this._year;
        },
        set: function( newValue ){
            if( newValue > 2004 ){
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    })
    book.year = 2005;
    console.log( book.edition );    //2
    
实例中 _year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性，而访问器属性 year 则包含一个 getter 函数和一个 setter 函数。getter 函数返回 _year 的值，setter 函数通过计算来确定正确的值，因此把 year 属性修改为 2005 会导致 _year 变成 2005，而 edition 变为 2，这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。

####定义多个属性

由于为对象定义多个属性的可能性很大， ECMAScript 又定义了一个 Object.defineProperties() 方法，利用这个方法可以通过描述符一次定义多个属性：

    var book = {};
    Object.defineProperties(book, {
        _year: {
            writable: true,
            value: 2004
        },
        edition: {
            writable: true,
            value: 2004
        },
        year: {
            get: function(){
                return this._year;
            },
            set: function( newValue ){
                if( newValue > 2004 ){
                    this._year = newValue;
                    this.edition += newValue - 2004;
                }
            }
        }
    });
    
以上代码在 book 对象上定义了两个属性属性( _year 和 edition ) 和一个访问器属性( year )。与 defineProperty() 定义对象相同，唯一的区别是这里的属性都是在同一时间创建的。

####读取属性的特性

使用 ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称，返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、enumerable、get和set；如果是数据属性，这个对象的属性有 configurable、enmerable、writable和value，如直接使用之前的 book 对象：

    var descriptor = Object.getOwnPropertyDescriptor( book, '_year' );
    console.log( descriptor.value );    //2004
    console.log( descriptor.configurable ); //false
    console.log( typeof descriptor.get );   //undefined
    
    var descriptor = Object.getOwnPropertyDescriptor( book, 'year' );
    console.log( descriptor.value );    //undefined
    console.log( descriptor.configurable ); //false
    console.log( typeof descriptor.get );   //function

####工厂模式

工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，。考虑到 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节：

    function createPerson( name, age, job){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.name = function(){
            alert( this.name );   
        };
        return o;
    }
    createPerson( 'mingxing', 23, 'front end');
    createPerson( 'tongtong', 23, 'front end');
    
函数 createPerson() 能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次的调用这个函数，而每次它都会返回一个包含三个属性的一个方法对象。工厂模式虽然解决了创建相似对象的问题，但却没有解决对象识别的问题( 即怎么知道一个对象的类型 )，随着 JavaScript 的发展，又一个新模式出现了。

####构造函数模式

ECMAScript 中的构造函数可用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外也可以创建自定义构造函数，从而自定义对象类型的属性和方法。例如使用构造函数模式将前面的例子重写：
    
    function Person( name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
            alert( this.name )
        };
    }
    var persion1 = new Person( 'mingxing', 23, 'front end');
    var persion2 = new Person( 'tongtong', 23, 'front end');
    
Person() 函数与 createPerson() 函数除了相同部分外，还存在一下不同之处：

1. 没有显式地创建对象；
2. 直接将属性和方法赋给 this 对象；
3. 没有 return 语句。

此外还应该主要导函数名 Person 使用的是大写字母 P，按照惯例构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。

要创建 Person 的新实力，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤：

1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象( 因此 this 就指向了这个新对象 )；
3. 执行构造函数中的代码( 为这个新对象添加属性 )；
4. 返回新对象。

前面例子中 person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 constructor ( 构造函数 )属性，该属性指向 Person：

    console.log( person1.constructor == Person );   // true
    console.log( person2.constructor == Person );   // true
    
对象的 constructor 属性最初是用来标示对象类型的。但是提到检测对象类型， instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证：

    console.log( person1 instanceof Object );   //true
    console.log( person1 instanceof Person );   //true
    console.log( person2 instanceof Object );   //true
    console.log( person2 instanceof Person );   //true
    
创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。在这个例子中 person1 和 person2 之所以同时是 Object 的实例，是因为所有对象均继承自 Object。

#####将构造函数当做函数

构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它跟普通函数也不会有什么两样。例如前面例子中定义的 Person() 函数可以通过下列任何一种方式来调用。
    
    //当做构造函数使用
    var person = new Person( 'mingxing', 24, 'front end' );
    Person.sayName();   // mingxing
    
    //作为普通函数调用
    Person( 'tongtong', 23, 'front end');   //添加到 window
    window.sayName();   //tongtong
    
    //在另一个对象的作用域中调用
    var o = new Object();
    Person.call( o, 'mingxing', 23, 'front end' );
    o.sayName();    //mingxing

以上例子中前两行代码展示了构造函数的经典用法，即使用 new 操作符来创建一个新对象。而接下来的两行代码在没有使用 new 的情况下，this 指向全局 window，因此在调用完函数以后可以通过 window 对象来调用 sayName()。最后也可以使用 call() 或者 apply() 在某个特殊对象的作用域中调用 Person() 函数。这里在对象 o 的作用域中调用，因此调用后 o 就拥有了 Person 所有属性和方法。

#####构造函数的问题

构造函数模式虽然好用，但并非没有缺点。使用构造函数的主要问题是，使用每个方法都要在每个实例中重新创建一遍，在例子中 person1 和 person2有一个名为 sayName() 的方法，但那两个方法不是同一个 Function 实例。不要忘了 ECMAScript 中的函数是对象，因此没定义一个函数，也就实例化了一个对象。从逻辑上讲，此时的构造函数也可以这样定义：

    Person( name, age, job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = new Function( 'alert( this.name )' );    //与函数声明在逻辑上是等价的
    }
    
从这个角度上来看构造函数，更容易明白每个 Person() 实例都包含一个不同的 Function() 实例( 以显示 name 属性 ) 的本质。说明白些，以这种方式创建函数，会导致不同作用域和标示符解析，但创建 Function 新实例机制仍然相同的。因此不同实例上的函数时不相等的，以下代码可以证明这一点：

    person1.sayName === person2.sayName     // false

然而创建两个完全相同任务的 Function 实例的确没有必要了；况且有 this 对象在，根本不用再执行代码前就把函数绑定到特定的对象上面，因此大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题：
    
    function Person(){
        …
        this.sayName = sayName;
    }
    function sayName(){
        console.log( this.name )
    }

这个例子中，把 sayName() 函数定义转移到了构造函数外部，而构造函数内部，我们将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName() 函数。这样做确实解决了两个函数作用一件事情的问题，可是新问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在这些问题可以通过使用原型模式来解决。

####原型模式

我们创建的每个函数都有一个 prototype( 原型 )属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法：

    function Person(){};
    Person.prototype.name = 'mingxing';
    Person.prototype.sayName = function(){ console.log( this.name ) };
    
    var person1 = new Person().sayName();    //mingxing
    var person2 = new Person().sayName();   //mingxing
    person1 === person2;        // true
    
#####理解原型对象

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向原型对象，在原型对象中查找具有给定名字的属性，如果找到了则返回该属性的值。 如前面例子中 person1.sayName() 就会执行这样一次搜索，当 person2.sayName() 时将会重现相同的搜索过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。

使用 `hasOwnProperty()` 方法可以检测一个属性是否存在于实例中，还是存在与原型中：

    function Person(){}
    Person.prototype.name = 'mingxing';
    var person1 = new Porson();
    person1.hasOwnProperty( 'name' );   //false
    person1.name = 'tongong';
    person1.hasOwnProperty( 'name' );   //true

#####原型与 in 操作符

两种方式使用 in：单独使用和在 for-in 中使用。

单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，不论该属性存在于实例中还是原型中。如上述例子中可以这样做：

    'name' in person1       //true
    
上述代码执行过程中 name 要么是直接在对象上访问到的，要么是在原型中访问到的。所以同时使用 hasOwnProperty() 方法和 in 操作符就可以确定该属性到底存在于对象中，还是存在于原型中：

    function fn( object, name){
        return !object.hasOwnProperty( name ) && ( name in object );
    }

在使用 for-in 返回的是所有能够通过对象访问的、可枚举的( enumerated )属性，其中包括存在于实例和原型中的属性。*屏蔽了原型中不可枚举属性( 即将[[Enumerable]]标记为 false 的属性)的实例也会在 for-in 中返回，因为根据规定，所有开发人员定义的属性都是可枚举的。

要直接取得对象上所有可以枚举的实例属性，可以使用 ECMAScript 5 的 Object.keys() 方法：

    function Person(){};
    Person.prototype.name = 'mingxing';
    Person.prototype.sayName = function(){ console.log( this.name ) };
    var person1 = new Porson();
    person1.age = 23;
    Object.keys( person1.prototype );    //name、sayName、age

而如果想要得到所有实例属性，无论它是否可以枚举，可以使用 Object.getOwnPropertyNames() 方法：

    Object.getOwnPropertyName( Person.prototype );      //constructor、name、sayName
    
#####更简单的原型语法

为了在创建原型属性时避免繁琐的 .prototype，我们使用了更常见的一种做法，就是用一个包含所有属性和方法的对象字面量来重写整个原型对象：

    function Person(){};
    Person.prototype = {
        name: 'tongtong',
        sayName: function(){
            this.name;
        }
    };

这样的写法虽然更简洁，但是有一个例外：constructor 属性不再指向 Person 了，这样的写法本质上市完全重写了默认的 prototype 对象，因此 对象不再自动获得 constructor 属性。此时尽管 instanceof 操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了：

    person1 instanceof Person;          //true
    person1.constructor == Person;      //false

如此 constructor 属性不再等于 Person，而如果 constructor 的值真的很重要，可以像下面这样特意将它设置会适当的值：

    function Person(){};
    Person.prototype = {
        constructor: Person,
        name: 'tongtong',
        sayName: function(){
            this.name;
        }
    };

不过以这种方式重设的 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true，如果想要保持它的特性可以在上述例子中使用 ES5 的 Object.defineProperty() ：

    Object.defineProperty( Person.prototype, 'constructor',{
        enumerable: false,
        value: Person
    });

#####原型的动态性

由于原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映处理---即使是先创建了实例后修改原型也照样如此：

    var person1 = new Person();
    Person.prototype.sayHi = function(){ alert( 'hi' ) };
    person1.sayHi();    //hi

而如果像下面这样：

    var person1 = new Person();
    Person.prototype = {
        name: 'tontong'
        …
    }

例子中完全重写了原型，切断了最初在调用构造函数时为实例添加的原型[[Prototype]]指针与构造函数之间的联系。所以请牢记： *实例中的指针仅指向原型，而不指向构造函数*。[157]

####原生对象的类型

原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型( Array、String ……) ，都是采用这种模式创建的。所以通过原生对象的原型，不仅可以取得所以默认方法引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，可以随时添加方法，如下给 String 类型添加一个名为 startsWith 的方法：

    String.prototype.startsWith = function( text ){
        return this.indexOf( text ) == 0;
    };
    var msg = 'tongtong mingxing';
    msg.startsWith( 'mingxing' );   //true
    
如上当前环境中的所有字符串就都可以调用到它。*尽管可以这样做，但是并不推荐去修改原生对象的原型，因为当你运行在某些支持你这个方法的环境中就可会导致命名冲突，这样做也可能会意外地重写原生方法*。

#####原型对象的问题

原型模式的最大问题是由其共享的本性说所导致的：

    Person.prototype = {
        arr: [1,2]
    }
    var person1 = new Person();
    var person2 = new Person();
    person1.arr.push( 3 );
    person2.arr;        //1,2,3

假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我没话可说。可是实例一般都是要有属于自己的全部属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。




