    function Person(){}
    Person.prototype.name = 'mingxing';
    Person.prototype.sayName = function(){
        console.log( this.name );
    }
    var person1 = new Person();
    var person2 = new Person();

####isPrototypeOf()

如果[[Prototype]]指向调用 isPrototypeOf() 方法的对象( Person.prototype )，那么这个方法就返回 true。
  
    Person.prototype.isPrototypeOf( person1 );  // true
    Person.prototype.isPrototypeOf( person2 );  // true
    
####getPrototypeOf() 获取原型中的值
    
    person1.name = 'tongtong';
    Object.getPrototypeOf( person1 ).sayName(); //mingxing
    Object.getPrototypeOf( person1 ) == Person.prototype;   //true

####每当代码读取某个对象的某个属性时，都会执行一次搜索

####通过对象实例并不能重写原型中的值

####hasOwnProperty() 检测一个属性是否存在于实例中

    person1.hasOwnProperty( 'name' );   //true
    person1.hasOwnProperty( 'age' );   //false
    
####in 访问对象属性

in 操作符会在通过对象能够访问给定属性时返回  true，无论该属性存在于实例中还是原型中。

    'name' in person1;      //true
    'job' in person1;       //false
    Person.prototype.job = 'end';
    'job' in person1;       //true

####in 配合 hasOwnProperty() 判断属性在原型中还是实例中

    function hasOwnProperty(obj, name){
        return !obj.hasOwnProperty( name ) && (name in obj);
    }
    hasOwnProperty( person1, 'name' );  //false     实例中
    delete person1.name;
    hasOwnProperty( person1, 'name' );  //true     原型中
    
